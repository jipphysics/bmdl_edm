#ifndef Included_cpp_mc_sampling
#define Included_cpp_mc_sampling

#include <cstddef>
#include <set>
#include <map>
#include <vector>
//#include <array>        // std::array
#include <iostream>
#include <cassert>
#include <algorithm>    // std::random_shuffle (uses std::rand) , std::shuffle (uses a random num. generator, e.g. std::mt19937) , std::max
#include <ctime>        // std::time
#include <cstdlib>      // std::rand, std::srand
#include <random>       // std::mt19937
#include <functional>   // std::ref
#include <math.h>       // exp , log , sqrt
#include <cmath>        // std::abs
#include "cpp_utils.h"
#include "cpp_graph.h"
#include "cpp_edm.h"

class LabelPool {
    public:
        LabelPool( std::mt19937 & eng ) : _eng( eng ) {}
        void resize( int num_labels ) {
            assert( num_labels > 0 );
            _labels.resize( num_labels );
            _labels_idxs.resize( num_labels );
            for ( int i = 0 ; i < num_labels ; i++ ) { 
                _labels[ i ] = i;
                _labels_idxs[ i ] = i;
            }
            _num_active_labels = 0;
        }
        ~LabelPool() {}
        int max_num_labels() { return _labels.size(); }
        int num_active_labels() { return _num_active_labels; }
        void assert_label_is_valid( int l ) {
            assert( ( l >= 0 ) and ( l < max_num_labels() ) );
        }
        bool is_label_active( int l ) {
            assert_label_is_valid( l );
            return _labels_idxs[ l ] < num_active_labels();
        }
        int activate_label() {
            assert( num_active_labels() < max_num_labels() );
            return _labels[ _num_active_labels++ ];
        }
        void deactivate_label( int l ) {
            // An active label is deactivated by swapping it with the last active one and then decreasing the number of active labels.
            assert_label_is_valid( l );
            assert( is_label_active( l ) );
            _swap_label( l , _labels[ num_active_labels() - 1 ] );
            _num_active_labels--;
        }
        void _swap_label( int l1 , int l2 ) {
            assert_label_is_valid( l1 );
            assert_label_is_valid( l2 );
            int i1 = _labels_idxs[ l1 ];
            int i2 = _labels_idxs[ l2 ];
            int tmp = _labels[ i1 ];
            _labels[ i1 ] = _labels[ i2 ];
            _labels[ i2 ] = tmp;
            _labels_idxs[ l1 ] = i2;
            _labels_idxs[ l1 ] = i1;    BUG HERE???
        }
        int & operator[] ( const int i ) {
            // Only active labels can be called by index.
            assert( ( i >= 0 ) and ( i < num_active_labels() ) );
            return _labels[ i ];
        }
        int random_label( int flag_new ) {
            // flag_new <int> : 0 , 1
            // With uniform probability distribution, it returns one label from the set
            //      { ...active labels... }
            // if flag_new = 0, or from the set
            //      { ...active labels... } U { new active label }
            // if flag_new = 1.
            assert( ( flag_new == 0 ) or ( flag_new == 1 ) );
            int i_max = std::min( num_active_labels() , max_num_labels() - 1 );
            std::uniform_int_distribution<> dist_i_first( 0 , i_max - 1 + flag_new );
            int i = dist_i_first( _eng );
            int l = _labels[ i ];
            if ( not is_label_active( l ) ) {
                return activate_label();
            }
            return l;
        }
    private:
        std::mt19937 &     _eng;
        std::vector< int > _labels;
        std::vector< int > _labels_idxs;
        int _num_active_labels;
};

class MC_Sampler {
    public:
        MC_Sampler( ExternalDegreeModel & edm , double beta_edm ) : _label_pool( _eng ) , _edm( edm ) , _beta_edm( beta_edm ) {
            // beta_edm should be passed here because the energy E, which depends on beta_edm, should be a fixed quantity during all the process.

            // Initialize the random number generator using the implementation in #include<random>.
            // http://stackoverflow.com/questions/15509270/does-stdmt19937-require-warmup
            // ... the following code is to seed the mt19937 generator with a "randomly generated" seed.
            std::random_device r; // This creates a "random device" random number generator which is non-deterministic.
            std::array< int , 624 > seed_data; // This is where the seed numbers generated by r() are stored.
            std::generate_n( seed_data.data() , seed_data.size() , std::ref( r ) ); // The seed numbers are generated and stored.
            std::seed_seq seq( std::begin( seed_data ) , std::end( seed_data ) ); // The seed numbers are used to create the seed for the mt19937 generator.
            _eng.seed( seq ); // The mt19937 is seeded.

            _label_pool.resize( edm.G().num_nodes() );
        
            // Create the vector of nodes, so they can be efficiently chosen at random.
            _nodes.clear();
            for ( Graph::const_iterator i_it = _edm.G().begin() ; i_it != _edm.G().end() ; i_it++ ) {
                int i = i_it.idx();
                _nodes.push_back( i );
            }        
            
        }
        ~MC_Sampler() {}
        
        ExternalDegreeModel & edm() { return _edm; }
        double E() { return _edm.j( _beta_edm ); } // Microscopic Energy

        int generate_candidate_node() {
            std::uniform_int_distribution<> dist_i( 0 , _edm.G().num_nodes() - 1 ); // So, notice, the distribution range is "num_labels + 1".
            return _nodes[ dist_i( _eng ) ];
        }
        int generate_candidate_label() {
            // This returns a candidate label which is chosen with uniform
            // probability from the set { ... existing labels ... } U { new label }.
            return _label_pool.random_label( 1 );
        }
        void attempt_MC_transition_step( double beta_prime , int i , int new_l ) {
            int    old_l   = _edm.get_node_label( i );
            double old_E   = E();
            _edm.set_node_label( i , new_l );
            double new_E   = E();
            double Delta_E = new_E - old_E;
            std::uniform_real_distribution<> dist( 0. , 1. );
            double xi = dist( _eng );
            // If delta_E > 0 iff new_E > old_E, then, exp( - beta_prime * Delta_E ) ) is a quantity in ( 0 , .1 ].
            // Then, the larger Delta_E = new_E - old_E, i.e. the larger the increase in the energy,
            // the smaller the probability of success.
            // On the other hand, if delta_E < 0, so the energy decreased, exp( - beta_prime * Delta_E ) ) > 1.
            // and success occurs.
            if ( xi > exp( - beta_prime * Delta_E ) ) {
                // The old state should be restored.
                _edm.set_node_label( i , old_l );
            }
        }
        int run_mc_sampler( double beta_prime , int num_MC_steps ) {
            // This function runs num_MC_steps Monte-Carlo steps at inverse-temperature beta_prime, starting from the current configuration. This function can be used to thermalize the EDM-state starting from some arbitrary initial configuration, and it can be used, also, to sample the thermodynamic equilibrium state, once thermalization has been achieved.
            int MC_step = 0;
            while ( MC_step < num_MC_steps ) {
                int atomic_step = 0;
                while ( atomic_step < ( int ) _nodes.size() ) {
                    // Perform an atomic step.
                    int i     = generate_candidate_node();
                    int new_l = generate_candidate_label();  
                    attempt_MC_transition_step( beta_prime , i , new_l );
                atomic_step++;
                }
                _edm.update_quantities();
            MC_step++;
            }
            return MC_step;
        }

    private:
        LabelPool                            _label_pool;
        ExternalDegreeModel &                  _edm;
        double                               _beta_edm;
        std::vector< int >                   _nodes;
        // For the random number generator
        std::mt19937                         _eng;

};
            
#endif // Included_cpp_annealing

#ifndef Included_cpp_meta_edm
#define Included_cpp_meta_edm

#include <cassert>
#include <cstddef>
#include <vector>
//#include <set>
//#include <map>
#include <iostream>
#include <string>
#include <sstream>
#include <algorithm>      // std::random_shuffle
#include <ctime>          // std::time
#include <cstdlib>        // std::rand, std::srand
#include <random>         // std::mt19937
#include <math.h>         // exp , log , sqrt
#include <cmath>          // std::abs , std::lgamma
//#include <limits>       // std::numeric_limits< double >::infinity()
//#include "cpp_static_graph.h"
//#include "cpp_ltn.h"
#include "cpp_edm.h"
#include "cpp_partition.h"
#include "cpp_info_theory.h"
#include "cpp_utils.h"
#include "cpp_runningstats.h"
#include "to_string_patch.h"

#include <iostream>
#include <fstream>

class meta_EDM {

    friend std::ostream& operator<<( std::ostream& os , meta_EDM & medm ) {
       std::string sep = " ";
       os << "meta_EDM{ ";
       os << medm._edm;
       os << " :: beta = " << patch::to_string( medm._beta );
       os << " , mdl = " << patch::to_string( medm.energy() );
       os << " }"; // << std::endl;       
       return os;
    }

    public:

        meta_EDM( ExternalDegreeModel & edm , double beta ) : _edm( edm ) , _beta( beta ) { re_seed_rng(); }
        meta_EDM( meta_EDM & meta_edm ) : _edm( meta_edm._edm ) , _beta( meta_edm._beta ) , _eng( meta_edm._eng ) { re_seed_rng(); }
        meta_EDM & operator=( const meta_EDM & other ) {
            _edm  = other._edm;
            _beta = other._beta;
            _eng  = other._eng;
            return ( * this );
        }
        ~meta_EDM() {}

        void set_beta( double beta ) { _beta = beta; }

        ExternalDegreeModel & edm() { return _edm; }

        void re_seed_rng() {
            std::random_device r; // This creates a "random device" random number generator which is non-deterministic.
            std::array< int , 624 > seed_data; // This is where the seed numbers generated by r() are stored.
            std::generate_n( seed_data.data() , seed_data.size() , std::ref( r ) ); // The seed numbers are generated and stored.
            std::seed_seq seq( std::begin( seed_data ) , std::end( seed_data ) ); // The seed numbers are used to create the seed for the mt19937 generator.
            _eng.seed( seq ); // The mt19937 is seeded.
        }
        double xi() {
            std::uniform_real_distribution<> dist( 0. , 1. );
            return dist( _eng );
        }

        double energy() { 
            // Here is where we chose the "energy" function.
            return _edm.effective_Hamiltonian( _beta ); 
        }
        void run_atomic_MC_step( double meta_beta , int node , int new_label ) {
            int old_label     = _edm.get_node_label( node );
            double old_energy = energy();
            _edm.set_node_label( node , new_label );
            double new_energy = energy();
            if ( xi() > exp( - meta_beta * ( new_energy - old_energy ) ) ) {
                _edm.set_node_label( node , old_label ); 
            }
        }
        void run_MC_step( double meta_beta ) {
            const int num_nodes = _edm.G().num_nodes();
            std::uniform_int_distribution<>  dist_nodes( 0 , 2 * num_nodes - 1 );
            // Run "num_nodes" atomic-steps.
            for ( int s = 0; s < num_nodes; s++ ) {
                int i = dist_nodes( _eng );
                int j = dist_nodes( _eng );
                int l;
                if ( i >= num_nodes ) { i -= num_nodes; }
                if ( j >= num_nodes ) { l = j - num_nodes; } else { l = _edm.get_node_label( j ); }
                run_atomic_MC_step( meta_beta , i , l );
            }
            _edm.update_quantities();
        }

        void thermalize( double meta_beta , int num_MC_steps , bool verbose ) {

            Chrono chr;
            int MC_step_report = 1;

            for ( int MC_step = 0 ; MC_step < num_MC_steps ; MC_step++ ) {
                run_MC_step( meta_beta );

                if ( MC_step % MC_step_report == 0 ) {
                    if ( verbose ) {
                        std::cout << "MC_THERMALIZE_PROGRESS_REPORT:" << std::endl;
                        std::cout << "MC_step = " << patch::to_string( MC_step ) << std::endl;
                        double ratio = ( ( double ) MC_step ) / ( ( double ) num_MC_steps );
                        std::cout << "MC_step / num_MC_steps = " << patch::to_string( ratio ) << std::endl;
                        std::cout << "elapsed time : [ sec ] = " << patch::to_string( chr.to_sec( chr.elapsed() ) ); // << std::endl;
                        std::cout << ", [ min ] = " << patch::to_string( chr.to_min( chr.elapsed() ) ); // << std::endl;
                        std::cout << ", [ hr ] = "  << patch::to_string( chr.to_hr( chr.elapsed() ) ) << std::endl;
                        std::cout << "energy = " << patch::to_string( energy() ) << std::endl;
                    }
                    MC_step_report *= 2;
                }
            }

            if ( verbose ) {
                std::cout << "MC_THERMALIZE_PROGRESS_FINAL_REPORT:" << std::endl;
                std::cout << "elapsed time : [ sec ] = " << patch::to_string( chr.to_sec( chr.elapsed() ) ); // << std::endl;
                std::cout << ", [ min ] = " << patch::to_string( chr.to_min( chr.elapsed() ) ); // << std::endl;
                std::cout << ", [ hr ] = "  << patch::to_string( chr.to_hr( chr.elapsed() ) ) << std::endl;
                std::cout << "energy = " << patch::to_string( energy() ) << std::endl;
            }

        } // thermalize

        void linear_annealing( double meta_beta_ini , double meta_beta_end , int num_MC_steps ) {
            double meta_T_ini   = 1. / meta_beta_ini;
            double meta_T_end   = 1. / meta_beta_end;
            double meta_T_delta = ( meta_T_end - meta_T_ini ) / ( ( double ) num_MC_steps );

            double meta_T = meta_T_ini;
            for ( int MC_step = 0 ; MC_step < num_MC_steps ; MC_step++ ) {
                double meta_beta = 1. / meta_T;
                run_MC_step( meta_beta );
                meta_T += meta_T_delta;
            }
        } // linear_annealing

        void powerlaw_annealing( double meta_beta_ini , double meta_beta_end , int max_num_MC_steps ) {
            double meta_T_ini   = 1. / meta_beta_ini;
            double meta_T_end   = 1. / meta_beta_end;
            assert( meta_T_end < meta_T_ini );

            int num_MC_steps = ( int ) ( meta_T_end / meta_T_ini );
            assert( num_MC_steps <= max_num_MC_steps );

            double meta_T = meta_T_ini;
            for ( int MC_step = 1 ; MC_step <= num_MC_steps ; MC_step++ ) {
                double meta_beta = 1. / meta_T;
                run_MC_step( meta_beta );
                meta_T = meta_T_ini / ( ( double ) MC_step );
            }
        } // power-law annealing

        void log_annealing( double meta_beta_ini , double meta_beta_end , int max_num_MC_steps ) {
            double meta_T_ini   = 1. / meta_beta_ini;
            double meta_T_end   = 1. / meta_beta_end;
            assert( meta_T_end < meta_T_ini );

            int ini_MC_step  = 4;
            int end_MC_step  = ( int )( std::exp( meta_T_end / meta_T_ini ) ) - ini_MC_step;
            assert( end_MC_step - ini_MC_step <= max_num_MC_steps );
            assert( end_MC_step - ini_MC_step  > 0 );

            double meta_T = meta_T_ini;
            for ( int MC_step = ini_MC_step ; MC_step <= end_MC_step ; MC_step++ ) {
                double meta_beta = 1. / meta_T;
                run_MC_step( meta_beta );
                meta_T += meta_T_ini / std::log( ( double ) MC_step );
            }
        } // log annealing

        void integrate( double meta_beta , int num_MC_steps , Partition & ground_truth_partition , int size_partition_pool , RunningStats & rs_NMIa_gt , RunningStats & rs_NMIg_gt , RunningStats & rs_NMIm_gt , RunningStats & rs_NMImi_gt , RunningStats & rs_AMI_gt , RunningStats & rs_NMIa_sg , RunningStats & rs_NMIg_sg , RunningStats & rs_NMIm_sg , RunningStats & rs_NMImi_sg , RunningStats & rs_AMI_sg , RunningStats & rs_energy , RunningStats & rs_num_communities , bool verbose ) {

            // FOR TESTING.
            //std::ofstream ofs;            
            //ofs.open ( "integrate.dat" );

            // This function assumes that an appropriate thermalization procedure was previously performed.

            assert( meta_beta > 0. );
            assert( num_MC_steps > 0 );
            assert( size_partition_pool > 1 ); // So, there are more than one partition to compare and the computation of the NMI and the AMI makes sense.

            // To draw pp.
            std::uniform_int_distribution<>  dist_p( 0 , size_partition_pool - 1 );

            // We allocate memory for the partition_pool.
            std::vector< Partition * > partition_pool( size_partition_pool );
            int p;
            for ( p = 0 ; p < size_partition_pool ; p++ ) {
                partition_pool[ p ] = new Partition( ground_truth_partition.size() );
            }
            Matrix< int > Nij;

            Chrono chr;
            int MC_step_report = 1;

            for ( int MC_step = 0 ; MC_step < num_MC_steps ; MC_step++ ) {

                //std::cout << "**************************************************" << std::endl;
                //std::cout << "MC_step = " << MC_step << std::endl;
                //std::cout << "meta_beta=" << meta_beta << std::endl; 
                //ofs << "**************************************************" << std::endl;
                //ofs << "MC_step = " << MC_step << std::endl;
                //ofs << "meta_beta=" << meta_beta << std::endl;

                run_MC_step( meta_beta );
                               
                int p1 = MC_step % partition_pool.size();
                Partition * sample_partition_1 = partition_pool[ p1 ];
                ( * sample_partition_1 ) = _edm.node_partition();

                // Once the partition pool is filled, we begin to sample the NMI and the AMI. We also sample the energy values.
                if ( MC_step >= size_partition_pool ) {

                    // Sample the energy.
                    rs_energy.insert( energy() );

                    // Sample the number of communities.
                    rs_num_communities.insert( _edm.num_active_labels() );

                    // For the ground-truth.
                    // .....................                    

                    // FOR TESTING.
                    //std::cout << "p1=" << p1 << std::endl; 
                    //std::cout << "( * sample_partition_1 ) = " << ( * sample_partition_1 ) << std::endl;
                    //std::cout << "ground_truth_partition = " << ground_truth_partition << std::endl;
                    //ofs << "p1=" << p1 << std::endl;
                    //ofs << "( * sample_partition_1 ) = " << ( * sample_partition_1 ) << std::endl;
                    //ofs << "ground_truth_partition = " << ground_truth_partition << std::endl;

                    compute_Nij( ( * sample_partition_1 ) , ground_truth_partition , Nij );

                    // FOR TESTING.
                    //std::cout << "Nij = " << Nij << std::endl;
  
                    double sample_NMIa_gt; // = NMI( Nij );
                    double sample_NMIg_gt; // = NMI( Nij );
                    double sample_NMIm_gt; // = NMI( Nij );
                    double sample_NMImi_gt; // = NMI( Nij );
                    double sample_AMI_gt; // = AMI( Nij );;
                    double dummy;
                  //compute_all_info_measures( Nij ,    Hi ,    Hj ,   Hij ,    MI ,           NMIa ,           NMIg ,           NMIm ,           NMImi ,   EMI ,           AMI )
                    compute_all_info_measures( Nij , dummy , dummy , dummy , dummy , sample_NMIa_gt , sample_NMIg_gt , sample_NMIm_gt , sample_NMImi_gt , dummy , sample_AMI_gt );

                    // FOR TESTING.
                    //std::cout << "sample_NMI_gt = " << sample_NMI_gt << std::endl;
                    //std::cout << "sample_AMI_gt = " << sample_AMI_gt << std::endl;
                    //ofs << "sample_NMI_gt = " << sample_NMI_gt << std::endl;
                    //ofs << "sample_AMI_gt = " << sample_AMI_gt << std::endl;

                    //if ( sample_NMIa_gt != -1. ) { 
                        // FOR TESTING.
                        //std::cout << "inserting NMIa_gt=" << sample_NMIa_gt << std::endl; 
                    rs_NMIa_gt.insert( sample_NMIa_gt ); 
                    //}
                    //if ( sample_NMIg_gt != -1. ) { 
                        // FOR TESTING.
                        //std::cout << "inserting NMIg_gt=" << sample_NMIg_gt << std::endl; 
                    rs_NMIg_gt.insert( sample_NMIg_gt ); 
                    //}
                    //if ( sample_NMIm_gt != -1. ) { 
                        // FOR TESTING.
                        //std::cout << "inserting NMIm_gt=" << sample_NMIm_gt << std::endl; 
                    rs_NMIm_gt.insert( sample_NMIm_gt ); 
                    //}
                    //if ( sample_NMImi_gt != -1. ) { 
                        // FOR TESTING.
                        //std::cout << "inserting NMIm_gt=" << sample_NMIm_gt << std::endl; 
                    rs_NMImi_gt.insert( sample_NMImi_gt ); 
                    //}

                    //if ( sample_AMI_gt != std::numeric_limits<double>::quiet_NaN() ) { 
                    //if ( sample_AMI_gt != -1. ) { 
                        // FOR TESTING.
                        //std::cout << "inserting AMI_gt=" << sample_AMI_gt << std::endl; 
                    rs_AMI_gt.insert( sample_AMI_gt ); 
                    //}

                    // For spin-glass.
                    // ...............

                    int p2 = ( MC_step + 1 ) % partition_pool.size();
                    Partition * sample_partition_2 = partition_pool[ p2 ];

                    // FOR TESTING.
                    //std::cout << "meta_beta=" << meta_beta << std::endl; 
                    //std::cout << "p1=" << p1 << " p2=" << p2 << std::endl; 
                    //std::cout << "( * sample_partition_1 ) = " << ( * sample_partition_1 ) << std::endl;
                    //std::cout << "( * sample_partition_2 ) = " << ( * sample_partition_2 ) << std::endl;
                    //ofs << "meta_beta=" << meta_beta << std::endl; 
                    //ofs << "p1=" << p1 << " p2=" << p2 << std::endl; 
                    //ofs << "( * sample_partition_1 ) = " << ( * sample_partition_1 ) << std::endl;
                    //ofs << "( * sample_partition_2 ) = " << ( * sample_partition_2 ) << std::endl;
 
                    compute_Nij( ( * sample_partition_1 ) , ( * sample_partition_2 ) , Nij );

                    // FOR TESTING.
                    //std::cout << "Nij = " << Nij << std::endl;
  
                    double sample_NMIa_sg; // = NMI( Nij );
                    double sample_NMIg_sg; // = NMI( Nij );
                    double sample_NMIm_sg; // = NMI( Nij );
                    double sample_NMImi_sg; // = NMI( Nij );
                    double sample_AMI_sg; // = AMI( Nij );;
                    //double dummy;
                  //compute_all_info_measures( Nij ,    Hi ,    Hj ,   Hij ,    MI ,           NMIa ,           NMIg ,           NMIm ,           NMImi ,   EMI ,           AMI )
                    compute_all_info_measures( Nij , dummy , dummy , dummy , dummy , sample_NMIa_sg , sample_NMIg_sg , sample_NMIm_sg , sample_NMImi_sg , dummy , sample_AMI_sg );

                    // FOR TESTING.
                    //std::cout << "sample_NMI_sg = " << sample_NMI_sg << std::endl;
                    //std::cout << "sample_AMI_sg = " << sample_AMI_sg << std::endl;
                    //ofs << "sample_NMI_sg = " << sample_NMI_sg << std::endl;
                    //ofs << "sample_AMI_sg = " << sample_AMI_sg << std::endl;
                    
                    //if ( sample_NMIa_sg != -1. ) { 
                        // FOR TESTING.
                        //std::cout << "inserting NMIa_sg=" << sample_NMIa_sg << std::endl; 
                    rs_NMIa_sg.insert( sample_NMIa_sg ); 
                    //}
                    //if ( sample_NMIg_sg != -1. ) { 
                        // FOR TESTING.
                        //std::cout << "inserting NMIg_sg=" << sample_NMIg_sg << std::endl;
                    rs_NMIg_sg.insert( sample_NMIg_sg ); 
                    //}
                    //if ( sample_NMIm_sg != -1. ) { 
                        // FOR TESTING.
                        //std::cout << "inserting NMIm_sg=" << sample_NMIm_sg << std::endl; 
                    rs_NMIm_sg.insert( sample_NMIm_sg ); 
                    //}
                    //if ( sample_NMImi_sg != -1. ) { 
                        // FOR TESTING.
                        //std::cout << "inserting NMIm_sg=" << sample_NMIm_sg << std::endl; 
                    rs_NMImi_sg.insert( sample_NMImi_sg ); 
                    //}

                    //if ( sample_AMI_sg != -1. ) { 
                        // FOR TESTING.
                        //std::cout << "inserting AMI_sg=" << sample_AMI_sg << std::endl; 
                    rs_AMI_sg.insert( sample_AMI_sg ); 
                    //}

                }

                if ( ( MC_step % MC_step_report == 0 ) and ( MC_step >= size_partition_pool ) ) {
                    if ( verbose ) {
                        std::cout << "MC_INTEGRATE_PROGRESS_REPORT:" << std::endl;
                        std::cout << "MC_step = " << patch::to_string( MC_step ) << std::endl;
                        double ratio = ( ( double ) MC_step ) / ( ( double ) num_MC_steps );
                        std::cout << "MC_step / num_MC_steps = " << patch::to_string( ratio ) << std::endl;
                        std::cout << "elapsed time : [ sec ] = " << patch::to_string( chr.to_sec( chr.elapsed() ) ); // << std::endl;
                        std::cout << ", [ min ] = " << patch::to_string( chr.to_min( chr.elapsed() ) ); // << std::endl;
                        std::cout << ", [ hr ] = "  << patch::to_string( chr.to_hr( chr.elapsed() ) ) << std::endl;
                        std::cout << "energy = " << patch::to_string( energy() ) << std::endl;
                        std::cout << "<NMIa_gt> = " << patch::to_string( rs_NMIa_gt.mean() ) << std::endl;
                        std::cout << "<NMIg_gt> = " << patch::to_string( rs_NMIg_gt.mean() ) << std::endl;
                        std::cout << "<NMIm_gt> = " << patch::to_string( rs_NMIm_gt.mean() ) << std::endl;
                        std::cout << "<NMImi_gt> = " << patch::to_string( rs_NMImi_gt.mean() ) << std::endl;
                        std::cout << "<AMI_gt> = " << patch::to_string( rs_AMI_gt.mean() ) << std::endl;
                        std::cout << "std_NMIa_gt = " << patch::to_string( rs_NMIa_gt.std() ) << std::endl;
                        std::cout << "std_NMIg_gt = " << patch::to_string( rs_NMIg_gt.std() ) << std::endl;
                        std::cout << "std_NMIm_gt = " << patch::to_string( rs_NMIm_gt.std() ) << std::endl;
                        std::cout << "std_NMImi_gt = " << patch::to_string( rs_NMImi_gt.std() ) << std::endl;
                        std::cout << "std_AMI_gt = " << patch::to_string( rs_AMI_gt.std() ) << std::endl;
                        std::cout << "std_of_mean_NMIa_gt = " << patch::to_string( rs_NMIa_gt.std_of_mean() ) << std::endl;
                        std::cout << "std_of_mean_NMIg_gt = " << patch::to_string( rs_NMIg_gt.std_of_mean() ) << std::endl;
                        std::cout << "std_of_mean_NMIm_gt = " << patch::to_string( rs_NMIm_gt.std_of_mean() ) << std::endl;
                        std::cout << "std_of_mean_NMImi_gt = " << patch::to_string( rs_NMImi_gt.std_of_mean() ) << std::endl;
                        std::cout << "std_of_mean_AMI_gt = " << patch::to_string( rs_AMI_gt.std_of_mean() ) << std::endl;
                        std::cout << "num_samples_gt = " << patch::to_string( rs_NMIa_gt.num_samples() ) << std::endl;
                        std::cout << "<NMIa_sg> = " << patch::to_string( rs_NMIa_sg.mean() ) << std::endl;
                        std::cout << "<NMIg_sg> = " << patch::to_string( rs_NMIg_sg.mean() ) << std::endl;
                        std::cout << "<NMIm_sg> = " << patch::to_string( rs_NMIm_sg.mean() ) << std::endl;
                        std::cout << "<NMImi_sg> = " << patch::to_string( rs_NMImi_sg.mean() ) << std::endl;
                        std::cout << "<AMI_sg> = " << patch::to_string( rs_AMI_sg.mean() ) << std::endl;
                        std::cout << "std_NMIa_sg = " << patch::to_string( rs_NMIa_sg.std() ) << std::endl;
                        std::cout << "std_NMIg_sg = " << patch::to_string( rs_NMIg_sg.std() ) << std::endl;
                        std::cout << "std_NMIm_sg = " << patch::to_string( rs_NMIm_sg.std() ) << std::endl;
                        std::cout << "std_NMImi_sg = " << patch::to_string( rs_NMImi_sg.std() ) << std::endl;
                        std::cout << "std_AMI_sg = " << patch::to_string( rs_AMI_sg.std() ) << std::endl;
                        std::cout << "std_of_mean_NMIa_sg = " << patch::to_string( rs_NMIa_sg.std_of_mean() ) << std::endl;
                        std::cout << "std_of_mean_NMIg_sg = " << patch::to_string( rs_NMIg_sg.std_of_mean() ) << std::endl;
                        std::cout << "std_of_mean_NMIm_sg = " << patch::to_string( rs_NMIm_sg.std_of_mean() ) << std::endl;
                        std::cout << "std_of_mean_NMImi_sg = " << patch::to_string( rs_NMImi_sg.std_of_mean() ) << std::endl;
                        std::cout << "std_of_mean_AMI_sg = " << patch::to_string( rs_AMI_sg.std_of_mean() ) << std::endl;
                        std::cout << "num_samples_sg = " << patch::to_string( rs_NMIa_sg.num_samples() ) << std::endl;
                    }
                    MC_step_report *= 2;
                }

            }

            if ( verbose ) {
                std::cout << "MC_INTEGRATE_PROGRESS_FINAL_REPORT:" << std::endl;
                std::cout << "elapsed time : [ sec ] = " << patch::to_string( chr.to_sec( chr.elapsed() ) ); // << std::endl;
                std::cout << ", [ min ] = " << patch::to_string( chr.to_min( chr.elapsed() ) ); // << std::endl;
                std::cout << ", [ hr ] = "  << patch::to_string( chr.to_hr( chr.elapsed() ) ) << std::endl;
                std::cout << "energy = " << patch::to_string( energy() ) << std::endl;
                std::cout << "<NMIa_gt> = " << patch::to_string( rs_NMIa_gt.mean() ) << std::endl;
                std::cout << "<NMIg_gt> = " << patch::to_string( rs_NMIg_gt.mean() ) << std::endl;
                std::cout << "<NMIm_gt> = " << patch::to_string( rs_NMIm_gt.mean() ) << std::endl;
                std::cout << "<NMImi_gt> = " << patch::to_string( rs_NMImi_gt.mean() ) << std::endl;
                std::cout << "<AMI_gt> = " << patch::to_string( rs_AMI_gt.mean() ) << std::endl;
                std::cout << "std_NMIa_gt = " << patch::to_string( rs_NMIa_gt.std() ) << std::endl;
                std::cout << "std_NMIg_gt = " << patch::to_string( rs_NMIg_gt.std() ) << std::endl;
                std::cout << "std_NMIm_gt = " << patch::to_string( rs_NMIm_gt.std() ) << std::endl;
                std::cout << "std_NMImi_gt = " << patch::to_string( rs_NMImi_gt.std() ) << std::endl;
                std::cout << "std_AMI_gt = " << patch::to_string( rs_AMI_gt.std() ) << std::endl;
                std::cout << "std_of_mean_NMIa_gt = " << patch::to_string( rs_NMIa_gt.std_of_mean() ) << std::endl;
                std::cout << "std_of_mean_NMIg_gt = " << patch::to_string( rs_NMIg_gt.std_of_mean() ) << std::endl;
                std::cout << "std_of_mean_NMIm_gt = " << patch::to_string( rs_NMIm_gt.std_of_mean() ) << std::endl;
                std::cout << "std_of_mean_NMImi_gt = " << patch::to_string( rs_NMImi_gt.std_of_mean() ) << std::endl;
                std::cout << "std_of_mean_AMI_gt = " << patch::to_string( rs_AMI_gt.std_of_mean() ) << std::endl;
                std::cout << "num_samples_gt = " << patch::to_string( rs_NMIa_gt.num_samples() ) << std::endl;
                std::cout << "<NMIa_sg> = " << patch::to_string( rs_NMIa_sg.mean() ) << std::endl;
                std::cout << "<NMIg_sg> = " << patch::to_string( rs_NMIg_sg.mean() ) << std::endl;
                std::cout << "<NMIm_sg> = " << patch::to_string( rs_NMIm_sg.mean() ) << std::endl;
                std::cout << "<AMI_sg> = " << patch::to_string( rs_AMI_sg.mean() ) << std::endl;
                std::cout << "std_NMIa_sg = " << patch::to_string( rs_NMIa_sg.std() ) << std::endl;
                std::cout << "std_NMIg_sg = " << patch::to_string( rs_NMIg_sg.std() ) << std::endl;
                std::cout << "std_NMIm_sg = " << patch::to_string( rs_NMIm_sg.std() ) << std::endl;
                std::cout << "std_NMImi_sg = " << patch::to_string( rs_NMImi_sg.std() ) << std::endl;
                std::cout << "std_AMI_sg = " << patch::to_string( rs_AMI_sg.std() ) << std::endl;
                std::cout << "std_of_mean_NMIa_sg = " << patch::to_string( rs_NMIa_sg.std_of_mean() ) << std::endl;
                std::cout << "std_of_mean_NMIg_sg = " << patch::to_string( rs_NMIg_sg.std_of_mean() ) << std::endl;
                std::cout << "std_of_mean_NMIm_sg = " << patch::to_string( rs_NMIm_sg.std_of_mean() ) << std::endl;
                std::cout << "std_of_mean_NMImi_sg = " << patch::to_string( rs_NMImi_sg.std_of_mean() ) << std::endl;
                std::cout << "std_of_mean_AMI_sg = " << patch::to_string( rs_AMI_sg.std_of_mean() ) << std::endl;
                std::cout << "num_samples_sg = " << patch::to_string( rs_NMIa_sg.num_samples() ) << std::endl;
            }

            // We free the allocated memory for the partition_pool.
            for ( p = 0 ; p < size_partition_pool ; p++ ) {
                delete partition_pool[ p ];
            } 

            // FOR TESTING.
            //ofs.close();

        } // integrate

    private:

        ExternalDegreeModel &                     _edm;
        double                                    _beta;
        std::mt19937                              _eng;

};

std::ostream& operator<<( std::ostream& os , ExternalDegreeModel & medm );

#endif // Included_cpp_meta_edm
